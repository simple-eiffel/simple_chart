note
	description: "Renders horizontal ASCII bar charts."
	author: "Generated by simple_codegen"
	date: "2026-01-16"

class
	BAR_CHART_RENDERER

create
	make

feature {NONE} -- Initialization

	make
			-- Create bar chart renderer.
		do
			create output.make_empty
			bar_width := Default_bar_width
			bar_character := '#'
		ensure
			output_empty: output.is_empty
			default_width: bar_width = Default_bar_width
		end

feature -- Access

	output: STRING
			-- Rendered output.

	as_string: STRING
			-- Get rendered chart as string.
		do
			Result := output.twin
		ensure
			result_attached: Result /= Void
		end

feature -- Settings

	bar_width: INTEGER
			-- Maximum width of bars in characters.

	bar_character: CHARACTER
			-- Character used for bar fill.

	set_bar_width (a_width: INTEGER)
			-- Set maximum bar width.
		require
			width_positive: a_width > 0
		do
			bar_width := a_width
		ensure
			width_set: bar_width = a_width
		end

	set_bar_character (a_char: CHARACTER)
			-- Set bar fill character.
		do
			bar_character := a_char
		ensure
			character_set: bar_character = a_char
		end

feature -- Status report

	is_rendered: BOOLEAN
			-- Has a chart been rendered?
		do
			Result := not output.is_empty
		end

feature -- Element change

	render (a_labels: ARRAYED_LIST [STRING]; a_values: ARRAYED_LIST [REAL_64])
			-- Render bar chart from labels and values.
		require
			labels_attached: a_labels /= Void
			values_attached: a_values /= Void
			same_count: a_labels.count = a_values.count
		local
			l_max_value: REAL_64
			l_max_label_width: INTEGER
			l_bar_length: INTEGER
			l_label: STRING
			l_value: REAL_64
			i: INTEGER
		do
			output.wipe_out
			
			if a_labels.is_empty then
				-- Nothing to render
			else
				-- Find maximum value for scaling
				l_max_value := 0.0
				across a_values as ic loop
					if ic > l_max_value then
						l_max_value := ic
					end
				end
				
				-- Find maximum label width for alignment
				l_max_label_width := 0
				across a_labels as ic loop
					if ic.count > l_max_label_width then
						l_max_label_width := ic.count
					end
				end
				
				-- Render each bar
				from
					i := 1
				until
					i > a_labels.count
				loop
					l_label := a_labels.i_th (i)
					l_value := a_values.i_th (i)
					
					-- Pad label to align bars
					output.append (padded_label (l_label, l_max_label_width))
					output.append (" | ")
					
					-- Calculate bar length (clamp negative to 0)
					if l_max_value > 0.0 then
						l_bar_length := (l_value / l_max_value * bar_width).truncated_to_integer
						if l_bar_length < 0 then
							l_bar_length := 0
						end
					else
						l_bar_length := 0
					end
					
					-- Render bar
					output.append (bar_string (l_bar_length))
					output.append (" ")
					output.append (l_value.out)
					output.append_character ('%N')
					
					i := i + 1
				end
			end
		ensure
			rendered_if_data: not a_labels.is_empty implies is_rendered
		end

feature -- Constants

	Default_bar_width: INTEGER = 40
			-- Default maximum bar width.

feature {NONE} -- Implementation

	padded_label (a_label: STRING; a_width: INTEGER): STRING
			-- Label padded to `a_width` characters.
		require
			label_attached: a_label /= Void
			width_valid: a_width >= a_label.count
		local
			l_padding: INTEGER
		do
			create Result.make (a_width)
			Result.append (a_label)
			l_padding := a_width - a_label.count
			from until l_padding = 0 loop
				Result.append_character (' ')
				l_padding := l_padding - 1
			end
		ensure
			correct_length: Result.count = a_width
		end

	bar_string (a_length: INTEGER): STRING
			-- String of bar characters with given length.
		require
			length_non_negative: a_length >= 0
		local
			i: INTEGER
		do
			create Result.make (a_length)
			from
				i := 1
			until
				i > a_length
			loop
				Result.append_character (bar_character)
				i := i + 1
			end
		ensure
			correct_length: Result.count = a_length
		end

invariant
	output_attached: output /= Void
	bar_width_positive: bar_width > 0
	is_rendered_consistency: is_rendered = (not output.is_empty)

end