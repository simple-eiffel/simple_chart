note
	description: "Loads CSV using SIMPLE_CSV. Provides row/column access."
	author: "Generated by simple_codegen"
	date: "2026-01-16"

class
	CSV_DATA_LOADER

create
	make

feature {NONE} -- Initialization

	make
			-- Create data loader.
		do
			create csv_parser.make
			create cached_headers.make (0)
		ensure
			parser_created: csv_parser /= Void
			no_data: not has_data
		end

feature -- Access

	row_count: INTEGER
			-- Number of data rows (excluding header).
		require
			has_data: has_data
		do
			Result := csv_parser.row_count - 1
			if Result < 0 then
				Result := 0
			end
		ensure
			non_negative: Result >= 0
		end

	column_count: INTEGER
			-- Number of columns.
		require
			has_data: has_data
		do
			if csv_parser.row_count > 0 then
				Result := csv_parser.row_at (1).count
			end
		ensure
			non_negative: Result >= 0
		end

	headers: ARRAYED_LIST [STRING]
			-- Column headers (first row of CSV).
		require
			has_data: has_data
		do
			Result := cached_headers.twin
		ensure
			result_attached: Result /= Void
		end

	all_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]]
			-- All data rows (excluding header).
		require
			has_data: has_data
		local
			i: INTEGER
		do
			create Result.make (row_count)
			from
				i := 2
			until
				i > csv_parser.row_count
			loop
				Result.extend (csv_parser.row_at (i))
				i := i + 1
			end
		ensure
			result_attached: Result /= Void
			correct_count: Result.count = row_count
		end

	column_values (a_column: INTEGER): ARRAYED_LIST [STRING]
			-- Values from column `a_column` (1-based, excludes header).
		require
			has_data: has_data
			column_valid: a_column >= 1 and a_column <= column_count
		local
			i: INTEGER
			l_row: ARRAYED_LIST [STRING]
		do
			create Result.make (row_count)
			from
				i := 2
			until
				i > csv_parser.row_count
			loop
				l_row := csv_parser.row_at (i)
				if a_column <= l_row.count then
					Result.extend (l_row.i_th (a_column))
				else
					Result.extend ("")
				end
				i := i + 1
			end
		ensure
			result_attached: Result /= Void
			correct_count: Result.count = row_count
		end

	column_as_numbers (a_column: INTEGER): ARRAYED_LIST [REAL_64]
			-- Numeric values from column `a_column` (1-based, excludes header).
		require
			has_data: has_data
			column_valid: a_column >= 1 and a_column <= column_count
		local
			l_values: ARRAYED_LIST [STRING]
			l_val: REAL_64
		do
			l_values := column_values (a_column)
			create Result.make (l_values.count)
			across l_values as ic loop
				if ic.is_double then
					l_val := ic.to_double
				else
					l_val := 0.0
				end
				Result.extend (l_val)
			end
		ensure
			result_attached: Result /= Void
			correct_count: Result.count = row_count
		end

feature -- Status report

	has_data: BOOLEAN
			-- Has data been loaded?
		do
			Result := csv_parser.row_count > 0
		end

feature -- Element change

	load_from_file (a_path: READABLE_STRING_GENERAL)
			-- Load CSV data from file at `a_path`.
		require
			path_not_empty: not a_path.is_empty
		local
			l_file: SIMPLE_FILE
		do
			create l_file.make (a_path)
			if l_file.exists then
				load_from_string (l_file.read_all)
			end
		end

	load_from_string (a_content: READABLE_STRING_GENERAL)
			-- Load CSV data from string `a_content`.
		require
			content_not_empty: not a_content.is_empty
		do
			csv_parser.parse (a_content.to_string_8)
			cache_headers
		ensure
			has_data_if_valid: csv_parser.row_count > 0 implies has_data
		end

feature {NONE} -- Implementation

	csv_parser: SIMPLE_CSV
			-- CSV parser.

	cached_headers: ARRAYED_LIST [STRING]
			-- Cached headers from first row.

	cache_headers
			-- Cache headers from first row.
		local
			l_row: ARRAYED_LIST [STRING]
		do
			cached_headers.wipe_out
			if csv_parser.row_count > 0 then
				l_row := csv_parser.row_at (1)
				across l_row as ic loop
					cached_headers.extend (ic)
				end
			end
		ensure
			headers_cached: csv_parser.row_count > 0 implies cached_headers.count > 0
		end

invariant
	parser_attached: csv_parser /= Void
	headers_attached: cached_headers /= Void
	data_consistency: has_data = (csv_parser.row_count > 0)
	headers_match_columns: has_data implies (cached_headers.count = column_count)

end