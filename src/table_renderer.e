note
	description: "Renders formatted ASCII tables."
	author: "Generated by simple_codegen"
	date: "2026-01-16"

class
	TABLE_RENDERER

create
	make

feature {NONE} -- Initialization

	make
			-- Create table renderer.
		do
			create output.make_empty
			create column_widths.make (0)
		ensure
			output_empty: output.is_empty
		end

feature -- Access

	output: STRING
			-- Rendered output.

	as_string: STRING
			-- Get rendered table as string.
		do
			Result := output.twin
		ensure
			result_attached: Result /= Void
		end

feature -- Status report

	is_rendered: BOOLEAN
			-- Has a table been rendered?
		do
			Result := not output.is_empty
		end

feature -- Element change

	render (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])
			-- Render table from headers and rows.
		require
			headers_attached: a_headers /= Void
			rows_attached: a_rows /= Void
		do
			output.wipe_out
			calculate_column_widths (a_headers, a_rows)
			
			-- Render header
			render_separator
			render_row (a_headers)
			render_separator
			
			-- Render data rows
			across a_rows as ic loop
				render_row (ic)
			end
			
			-- Render bottom border
			if not a_rows.is_empty then
				render_separator
			end
		ensure
			rendered_if_headers: not a_headers.is_empty implies is_rendered
		end

feature {NONE} -- Implementation

	column_widths: ARRAYED_LIST [INTEGER]
			-- Width of each column.

	calculate_column_widths (a_headers: ARRAYED_LIST [STRING]; a_rows: ARRAYED_LIST [ARRAYED_LIST [STRING]])
			-- Calculate column widths based on content.
		require
			headers_attached: a_headers /= Void
			rows_attached: a_rows /= Void
		local
			l_col: INTEGER
			l_width: INTEGER
			l_cell: STRING
		do
			column_widths.wipe_out
			
			-- Start with header widths
			across a_headers as ic loop
				column_widths.extend (ic.count)
			end
			
			-- Update with row content widths
			across a_rows as row_ic loop
				from
					l_col := 1
				until
					l_col > row_ic.count
				loop
					l_cell := row_ic.i_th (l_col)
					l_width := l_cell.count
					
					if l_col <= column_widths.count then
						if l_width > column_widths.i_th (l_col) then
							column_widths.put_i_th (l_width, l_col)
						end
					else
						column_widths.extend (l_width)
					end
					
					l_col := l_col + 1
				end
			end
		ensure
			columns_calculated: column_widths.count >= a_headers.count
		end

	render_separator
			-- Render horizontal separator line.
		local
			l_first: BOOLEAN
		do
			output.append_character ('+')
			l_first := True
			across column_widths as ic loop
				if not l_first then
					output.append_character ('+')
				end
				output.append (repeat_char ('-', ic + 2))
				l_first := False
			end
			output.append_character ('+')
			output.append_character ('%N')
		end

	render_row (a_cells: ARRAYED_LIST [STRING])
			-- Render a single row.
		require
			cells_attached: a_cells /= Void
		local
			l_col: INTEGER
			l_cell: STRING
			l_width: INTEGER
		do
			output.append_character ('|')
			from
				l_col := 1
			until
				l_col > column_widths.count
			loop
				if l_col <= a_cells.count then
					l_cell := a_cells.i_th (l_col)
				else
					l_cell := ""
				end
				
				l_width := column_widths.i_th (l_col)
				output.append_character (' ')
				output.append (padded_cell (l_cell, l_width))
				output.append_character (' ')
				output.append_character ('|')
				
				l_col := l_col + 1
			end
			output.append_character ('%N')
		end

	padded_cell (a_content: STRING; a_width: INTEGER): STRING
			-- Cell content padded to width.
		require
			content_attached: a_content /= Void
			width_non_negative: a_width >= 0
		local
			l_padding: INTEGER
		do
			create Result.make (a_width)
			Result.append (a_content)
			l_padding := a_width - a_content.count
			from until l_padding <= 0 loop
				Result.append_character (' ')
				l_padding := l_padding - 1
			end
		ensure
			correct_min_length: Result.count >= a_width
		end

	repeat_char (a_char: CHARACTER; a_count: INTEGER): STRING
			-- String with character repeated.
		require
			count_non_negative: a_count >= 0
		local
			i: INTEGER
		do
			create Result.make (a_count)
			from
				i := 1
			until
				i > a_count
			loop
				Result.append_character (a_char)
				i := i + 1
			end
		ensure
			correct_length: Result.count = a_count
		end

invariant
	output_attached: output /= Void
	column_widths_attached: column_widths /= Void
	is_rendered_consistency: is_rendered = (not output.is_empty)

end